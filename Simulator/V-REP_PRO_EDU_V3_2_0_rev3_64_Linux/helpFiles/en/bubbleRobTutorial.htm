<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>BubbleRob tutorial</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>



<h1>BubbleRob tutorial</h1>

<p>This tutorial will try to introduce quite many V-REP functionalities while designing the simple mobile robot BubbleRob. The V-REP scene file related to this tutorial is located in V-REP's installation folder's &quot;tutorials\BubbleRob&quot; folder. Following figure illustrates the simulation scene that we will design:<br>
</p>

<p align=center><img src="images/bubbleRobTut1.jpg"></p>
<br>

<p>First of all, freshly start V-REP. The simulator displays a default <a href="scenes.htm">scene</a>. We will start by designing BubbleRob's eyes first. Instead of <a href="importExport.htm">importing shapes</a>, we will directly create them as <a href="primitiveShapes.htm">primitives</a>.<br>
</p>

<p>Right click in the scene and quickly release the button: a popup menu appears. Select [Popup menu --&gt; Add --&gt; Primitive shape --&gt; Sphere] (alternatively you can also select [Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]), deselect <strong>Create pure shape</strong>, then enter following values:<br>
</p>

<p align=center><img src="images/bubbleRobTut2.jpg"></p>
<br>

<p>Click ok. Move closer to the newly added <a href="shapes.htm">shape</a> by using the mouse wheel. Clicking with the left button allows you to shift the <a href="cameras.htm">camera</a> you are currently looking through along the clicked point. Right click the newly added shape and move the mouse while keeping the right mouse button down: this allows you to rotate the camera about the clicked point.<br>
</p>

<p>
If you deselected the newly added shape, select it again by simply clicking it with the left mouse button. Now enter the <a href="triangleEditMode.htm">triangle edit mode</a> (make sure simulation is not running). The shape is now in triangle edit mode: </p>

<p align=center><img src="images/bubbleRobTut3.jpg"></p>
<br>

<p>Switch to <a href="pagesAndViews.htm">page</a> 6 with the appropriate toolbar button:<br>
</p>

<p align=center><img src="images/pages.jpg"></p>
<br>


<p>We now see the scene from above, and in orthographic projection mode. Move closer to the shape. Keeping the shift button down, select several triangles at a time until you selected all triangles except for a ring as displayed in following sequence:<br>
</p>

<p align=center><img src="images/bubbleRobTut5.jpg"></p>
<br>

<p>Remember that a shift selection will select all triangles within the selection square, also those that are located on the other side and not directly visible. Try double-clicking the floating view to swap its content with the main view. Make sure that only desired triangles are selected.  Now, with the triangles selected, click <strong>Extract shape</strong> in the triangle edit mode dialog. This just generated another shape with the selected triangles. Press the delete key to remove the selected triangles. The added shape now becomes visible. Leave the edit mode by closing the shape edit mode dialog. Switch back to page 1.<br>
</p>

<p>Select the ring shape. All objects in the scene are also visible in the <a href="userInterface.htm#SceneHierarchy">scene hierarchy</a>. The ring shape appears there too and is highlighted (since selected). Double click its icon to open the <a href="shapeProperties.htm">shape properties</a> dialog. In the dialog that just opened, click <strong>Adjust outside color</strong>. Another dialog will open and then select <strong>Ambient/diffuse component</strong>. This allows you to adjust the ambient/diffuse color component of the ring shape. Once done, select the inner shape (the one you extracted in the edit mode) and adjust its color in the same way as you did with the ring shape. This is what you should have by now:<br>
</p>

<p align=center><img src="images/bubbleRobTut6.jpg"></p>
<br>

<p>Next we will add another spheroid with following dimensions: (0.02,0.02,0.015): add a primitive sphere and in the dialog, enter 0.02 for the X and Y-sizes, and 0.015 for the Z-size. Here also make sure you deselect the <strong>Create pure shape</strong> option beforehand. Adjust the color of the newly added shape by selecting it, then selecting the ring shape (hold the ctrl-key down to select more than one object), and in the shape dialog click the <strong>Apply to selection</strong> button in the colors section.<br>
</p>

<p>Now select all 3 shapes in the scene and click [menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes]. You can notice that all 3 shapes are now grouped and appear as a single object in the scene hierarchy (the icon looks like it is composed by several items). The simulator also sees and handles the 3 shapes as a single object from now on (as a <a href="shapes.htm">grouped shape</a>). <br>
</p>

<p>
What we now have is an <em>eye</em>: </p>

<p align=center><img src="images/bubbleRobTut7.jpg"></p>
<br>

<p>Next we will add the body of BubbleRob. Add two primitive spheres of diameter 0.2 (in the dialog, enter 0.2 for the X, Y and Z-sizes). When adding the second sphere, make sure the <strong>Create pure shape</strong> option stays selected. You will notice in the scene hierarchy that the pure shape is represented with a different icon (a cube). <a href="shapes.htm">Pure shapes</a> perform much better during dynamics calculations (i.e. faster and more stable), they however cannot be very complex or look very detailed. For that reason, it is often preferable to have the underlying dynamic content of a scene invisible. This is what we will do next: send the pure shape into the visibility layer 9 (disabled by default). For that, select the pure sphere you just added (select it in the scene hierarchy), then open the <a href="commonPropertiesDialog.htm">object common properties</a> dialog.</p>

<p>While the pure shape is selected, activate the 9th layer and deactivate the first layer in the <strong>Visibility layers</strong> section. The pure shape is now not visible anymore, since V-REP displays by default the first 8 layers and hides the last 8. Scene layers can be turned on/off in the <a href="layerSelectionDialog.htm">layers dialog</a> [Menu bar --&gt; Tools --&gt; Layers] or by clicking the appropriate toolbar button:<br>
</p>

<p align=center><img src="images/layerSelection1.jpg"></p>
<br>

<p>In the object common properties dialog notice how the pure shape has all <strong>object special properties</strong> disabled by default. Now select the non-pure sphere and notice in the same dialog how most <strong>object special properties</strong> are enabled by default. In the <a href="shapeDynamicsProperties.htm">shape dynamics properties</a> dialog (go to the <a href="shapeProperties.htm">shape properties</a> dialog, then click <strong>Show dynamic properties dialog</strong>), notice also how the pure sphere has the <strong>Static</strong> option unchecked and the <strong>Respondable</strong> option checked. The non-pure shape on the other hand has the <strong>Static</strong> option checked and the <strong>Respondable</strong> option unchecked by default.<br>
</p>

<p>Now open the <a href="coordinateDialog.htm#translation">position and translation dialog</a>, <a href="coordinateDialog.htm">s</a>elect the two spheres representing BubbleRob's body, and in the dialog's section 3, enter -0.1 for <strong>Along Z</strong>. Make sure the<strong> Relative to</strong>-item is set to <strong>World</strong>. Then click <strong>Translate selection</strong>. This translates all selected objects by -0.1 along the absolute Z-axis. Now you can also change the color of the visible sphere (the non-pure sphere).<br>
</p>

<p>Deselect all the objects (either by pressing the esc-key, or by clicking no specific object in the scene). Select the grouped shape in the scene hierarchy (the eye actually), then in the same dialog but in section 2 this time,  enter 0.1 for <strong>Z-coordinate</strong> (make sure the <strong>Relative to</strong> item is set to <strong>World</strong>). This will change the absolute Z-coordinate of all selected objects to 0.1. The eye of BubbleRob appears at the top of the sphere. In the<a href="coordinateDialog.htm#rotation"> orientation and rotation dialog</a>, in section 3,  enter 60 for <strong>Around Y</strong>, then click <strong>Rotate selection</strong>.<br>
</p>

<p>Now copy the eye with [Popup menu --&gt; Edit --&gt; Copy selected objects]. You can also copy it with the ctrl-c key combination. Paste the copy with [Popup menu --&gt; Edit --&gt; Paste buffer] (for that operation you could also use the ctrl-v key combination). Select one of the two superposed eyes (it doesn't matter which one you pick) then in the<a href="coordinateDialog.htm#rotation"> orientation and rotation dialog</a>, in section 3,  enter 30 for <strong>around Z</strong>, clear the previously entered 60 for <strong>around Y</strong> (enter zero), then click <strong>Rotate selection</strong>. Select the other visible eye, enter -30 for <strong>around Z</strong>, then click <strong>Rotate selection</strong>. The eyes are in place now. This is what you should have:<br>
</p>

<p align=center><img src="images/bubbleRobTut8.jpg"></p>
<br>

<p>Just as a side-note: in above figures you can notice that the underlying dynamic model does not take into account the eyes.<br>
</p>

<p>Next we will add a <a href="proximitySensors.htm">proximity sensor</a> so that BubbleRob knows when it is approaching obstacles: click [Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]. In the <a href="coordinateDialog.htm#rotation">orientation and rotation dialog</a>, in section 3, enter 90 for <strong>Around Y</strong> and for <strong>Around Z</strong>, then click <strong>Rotate selection</strong>. In the <a href="coordinateDialog.htm#translation">position and translation dialog</a>, in section 2,  enter 0.1 for <strong>X-coordinate</strong>. The proximity sensor is now correctly positioned relative to BubbleRob's body. Double-click the proximity sensor's icon in the scene hierarchy to open <a href="proximitySensorPropertiesDialog.htm">its properties</a> dialog. Click <strong>Show volume parameter dialog</strong> to open the <a href="proximitySensorVolumeDialog.htm">proximity sensor volume dialog</a>. Set <strong>Angle</strong> to 30 and <strong>Range</strong> to 0.15. Then, in the <a href="proximitySensorPropertiesDialog.htm">proximity sensor properties</a>, click <strong>Adjust detection parameters</strong>. This opens the <a href="proximitySensorDetectionParameterDialog.htm">proximity sensor detection parameter dialog</a>. Uncheck  <strong>Don't allow detections if distance smaller than</strong>, and check the <strong>Limited angle detection</strong> item. By doing so you inform the simulator that the sensor will only detect surfaces whose angle between their normal vector and detection ray is smaller than the indicated value (typically, ultrasonic sensors will behave like this). Uncheck <strong>Occlusion check</strong>. Close that dialog. In the scene hierarchy, double-click the proximity sensor's name, so that you can edit its name. Enter &quot;sensingNose&quot; and press enter.<br>
</p>

<p>Rename the invisible body sphere to &quot;bubbleRob&quot; (invisible objects' names appear in grey instead of black in the scene hierarchy). Group the eyes with the visible body sphere, and rename the new grouped shape to &quot;body&quot;. Select [Menu bar --&gt; Edit --&gt; Reorient bounding box --&gt; with reference frame of world]. This can only be done with non-pure shapes and will align the <a href="shapeReferenceFrames.htm">bounding box</a> for the shape with the world, i.e. <a href="eulerAngles.htm">Euler angles</a> at (0,0,0). By default, the bounding boxes are always automatically chosen so that their volume are smallest. Bounding box reorientation is not compulsatory, but in certain situations like in ours, it is convenient to be able, at a later stage, to reset a shape to its <em>natural</em> orientation by setting its Euler angles all to zero.<br>
</p>

<p>Select &quot;body&quot; and open the shape dynamics dialog. Notice how the <strong>Static</strong> item is checked and the <strong>Respondable</strong> item is unchecked. This indicates that the <a href="dynamicsModule.htm">dynamics engine</a> will ignore this shape; indeed, we only want the dynamics engine to simulate the shapes that we put to layer 9, not the other ones. Open the object common properties dialog, and while &quot;body&quot; is still selected notice how the <strong><a href="collidableObjects.htm">Collidable</a></strong>, <strong><a href="measurableObjects.htm">Measurable</a></strong>, <strong><a href="renderableObjects.htm">Renderable</a></strong> and <strong><a href="detectableObjects.htm">Detectable</a></strong> items are checked. This indicates that &quot;body&quot; is enabled for <a href="collisionDetection.htm">collision detection</a>, <a href="distanceCalculation.htm">distance calculation</a>, and is visible to <a href="visionSensors.htm">vision sensors</a> as well as <a href="proximitySensors.htm">proximity sensors</a>.<br>
</p>

<p>Select &quot;body&quot;, &quot;sensingNose&quot; then &quot;bubbleRob&quot; and click [Menu bar --&gt; Edit --&gt; Make last selected object parent]. This attaches &quot;body&quot; and &quot;sensing nose&quot; to &quot;bubbleRob&quot; (have a look at the scene hierarchy). The same operation can directly be performed in the scene hierarchy by dragging &quot;body&quot; onto &quot;bubbleRobb&quot;, then dragging &quot;sensingNose&quot; onto &quot;bubbleRob&quot;. Select &quot;bubbleRob&quot; and translate it by 0.12 along the world's Z axis (use the <a href="coordinateDialog.htm">Coordinates and transformations dialog</a>). This is what you should have by now:<br>
</p>

<p align=center><img src="images/bubbleRobTut9.jpg"></p>
<br>

<p>Next we will take care of BubbleRob's wheels. Create a new scene with [Menu bar --&gt; File --&gt; New scene]. <br>
</p>
<p>We will use the second scene in order not to be disturbed by the already existing objects in the first scene. Individual scenes in V-REP are fully independent, however they share a same copy buffer. Add a pure primitive cylinder with dimensions (0.08,0.08,0.02). With the cylinder selected, activate its 9th layer (but this time keep the first layer also activated: the cylinder will now be visible in layer 1 and layer 9). In the shape dialog, adjust the wheels's color. In the object common properties dialog, check the <strong>Collidable</strong>, <strong>Measurable</strong>, <strong>Renderable</strong> and <strong>Detectable</strong> items. Set the cylinder's absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0) (you can do this in the <a href="coordinateDialog.htm">Coordinates and transformations dialog</a>).  Change the name to &quot;leftRespondableWheel&quot;. Copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. Rename the copy to &quot;rightRespondableWheel&quot;. Select the two wheels, copy them, then switch back to scene 1. Paste the wheels.<br>
</p>

<p>We now need to add <a href="joints.htm">joints</a> (or motors) for the wheels. Click [Menu bar --&gt; Add --&gt; Joint --&gt; Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. Keep the joint selected and also select &quot;leftRespondableWheel&quot;. In the  <a href="coordinateDialog.htm#translation">position and translation dialog</a>, in section 2, click the <strong>Apply to selection</strong> button at the bottom of that section, then in the <a href="coordinateDialog.htm#rotation">orientation and rotation dialog</a>, in section 2 also, do the same. This sets the joint to the exact same position and orientation as &quot;leftRespondableWheel&quot;. Rename the joint to &quot;leftMotor&quot;. Double-click the joint's icon in the scene hierarchy to open the <a href="jointProperties.htm">joint properties</a> dialog. Then click <strong>Show dynamic parameters</strong> to open the <a href="jointDynamicsProperties.htm">joint dynamics properties</a> dialog. Click <strong>Motor enabled</strong>. Copy and paste the joint and rename the copy to &quot;rightMotor&quot;. Set the right motor to the same position as &quot;rightRespondableWheel&quot; (in the same way as you did with the left motor).<br>
</p>

<p>Select &quot;leftRespondableWheel&quot; then &quot;leftMotor&quot; and click [Menu bar --&gt; Edit --&gt; Make last selected object parent]. Do the same with &quot;rightrespondableWheel&quot; and &quot;rightMotor&quot;. Now make &quot;bubbleRob&quot; parent of the left and right motors.<br>
</p>

<p>Next we will add a small slider (or caster) for the third contact point to the ground. Create a new scene (scene 3) and add a pure primitive sphere with diameter 0.05. Keep the layer 1 activated for the sphere, but in addition activate also layer 9. Make the shape collidable, measurable, renderable and detectable as you did for the two wheels earlier. Adjust its color, and set the <strong>Material</strong> to <em>noFrictionMaterial</em>. Remember that there are distinct properties for the <a href="dynamicsModule.htm#bullet">Bullet</a>, <a href="dynamicsModule.htm#ode">ODE</a> or <a href="dynamicsModule.htm#vortex">Vortex</a> physics engines). Rename the shape to &quot;respondableCaster&quot;. Add a<a href="forceSensors.htm"> force sensor object</a> with [Menu bar --&gt; Add --&gt; Force sensor]. Rename it to &quot;bodyCasterLink&quot; and shift it up by 0.05. Make &quot;bodyCasterLink&quot; parent of &quot;respondableCaster&quot;. Copy both objects, switch back to scene 1 and paste the objects. Select &quot;bodyCasterLink&quot; and set its absolute x coordinate to -0.07. Make &quot;bubbleRob&quot; parent of &quot;bodyCasterLink&quot;. Deactivate all layers except layer 12 for &quot;bodyCasterLink&quot;. If you now carefully observe &quot;respondableCaster&quot; and &quot;bubbleRob&quot; you will notice that they slightly interfere. To avoid strange effects during dynamics simulation, we have to inform V-REP that both objects do not mutually collide, and we do this in following way: in the shape dynamics dialog, for &quot;respondableCaster&quot; set the <strong>local respondable mask</strong> to 00001111, and for &quot;bubbleRob&quot; set the<strong> local respondable mask</strong> to 11110000. This is what you should have now:<br>
</p>

<p align=center><img src="images/bubbleRobTut10.jpg"></p>
<br>

<p>Run the <a href="simulation.htm">simulation</a> with [Menu bar --&gt; Simulation --&gt; Start simulation]. Notice how BubbleRob slightly moves. Stop the simulation with [Menu bar --&gt; Simulation --&gt; Stop simulation]. Alternatively you can also start/pause/stop simulations with the corresponding toolbar buttons:<br>
</p>

<p align=center><img src="images/simulation1.jpg"></p>
<br>

<p>Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes (e.g. masses should not differ too much from each other, etc.). Select &quot;leftRespondableWheel&quot;, &quot;rightRespondableWheel&quot; and &quot;respondableCaster&quot;, and in the shape dynamics dialog click three times <strong>M=M*2 (for all selected shapes)</strong>. The effect is that all selected shapes will have their masses multiplied by 8. Run the simulation and notice how stability has improved. Stop the simulation. In the joint dynamics dialog, set <strong>Target velocity</strong> to 50 for both motors. Run the simulation. BubbleRob now moves forward and eventually falls off the floor. Stop the simulation and reset the <strong>Target velocity</strong> item to zero for both motors.<br>
</p>

<p>The object &quot;bubbleRob&quot; is at the base of all <a href="objects.htm">objects</a> that will later form the BubbleRob <a href="models.htm">model</a>. We will define the model a little bit later. In the mean time, we want to define a collection of objects that represent BubbleRob. For that we define a <a href="collections.htm">collection object</a>. Click [Menu bar --&gt; Tools --&gt; Collections] to open the <a href="collectionsDialog.htm">collection dialog</a>. Alternatively you can also open the dialog by clicking the appropriate toolbar button:<br>
</p>

<p align=center><img src="images/collectionDialog1.jpg"></p>
<br>

<p>In the collection dialog, click <strong>Add new collection</strong>. A new collection object appears in the list just below. For now the newly added collection is still empty (not defined). While the new collection item is selected in the list, select &quot;bubbleRob&quot; in the scene hierarchy, and then click <strong>Add</strong> in the collection dialog. Our collection is now defined as containing all objects of the hierarchy tree starting at the &quot;bubbleRob&quot; object (the collection's composition is displayed in the <strong>Composing elements and attributes</strong> section). To edit the collection name, double-click it. Rename the collection to &quot;bubbleRobCollection&quot;. Close the collection dialog.<br>
</p>

<p>At this stage we want to be able to track the minimum distance between BubbleRob and any other object. For that, open the <a href="distanceCalculation.htm">distance dialog</a> with [Menu bar --&gt; Tools --&gt; Calculation module properties]. Alternatively you can also open the calculation module properties dialog with the appropriate toolbar button:<br>
</p>


<p align=center><img src="images/calculationModuleButton.jpg"></p>
<br>



<p>In the distance dialog, click <strong>Add new distance object</strong> and select a distance pair: &quot;[collection] bubbleRobCollection&quot; - &quot;all other measurable objects in the scene&quot;. This just added a distance object that will measure the smallest distance between collection &quot;bubbleRobCollection&quot; (i.e. any <a href="measurableObjects.htm">measurable object</a> in that collection) and any other measurable object in the scene. Rename the distance object to &quot;bubbleRobDistance&quot; (double-click the distance object). Close the distance dialog. When you now run the simulation, you won't see any difference, since the distance object will try to measure (and display) the smallest distance segment between &quot;BubbleRob&quot; and any other measurable object in the scene. The problem is that at this stage there is no other measurable object in the scene (the shape defining the floor has its measurable property turned off by default). At a later stage in this tutorial, we will add obstacles to our scene.<br>
</p>


<p>Next we are going to add a <a href="graphs.htm">graph object</a> to BubbleRob in order to display above smallest distance, but also BubbleRob's trajectory over time. Click [Menu bar --&gt; Add --&gt; Graph] and rename it to &quot;bubbleRobGraph&quot;. Make the graph child of &quot;bubbleRob&quot;, and set the graph's absolute coordinates to (0,0,0.005).  Now open the <a href="graphPropertiesDialog.htm">graph properties</a> dialog by double-clicking its icon in the scene hierarchy. Uncheck <strong>Display XYZ-planes</strong>. Click <strong>Add new data stream to record</strong> and select &quot;Object: absolute x-position&quot; for the <strong>Data stream type</strong>, and &quot;bubbleRobGraph&quot; for the <strong>Object / item to record</strong>. An item has appeared in the <strong>Data stream recording list</strong>. That item is a data stream of &quot;bubbleRobGraph&quot;'s absolute x-coordinate (i.e. the &quot;bubbleRobGraph&quot;'s object absolute x position will be recorded). Now we also want to record the y and z positions: add those data streams in a similar way as above. We now have 3 data streams that represent BubbleRob's x-, y- and z-trajectories. We are going to add one more data stream so that we are able to track the minimum distance between our robot and its environment. Click <strong>Add new data stream to record</strong> and select &quot;Distance: segment length&quot; for the <strong>Data stream type</strong>, and &quot;bubbleRobDistance&quot; for the <strong>Object / item to record</strong>.  In the <strong>Data stream recording list</strong>, rename &quot;Data&quot; to &quot;bubbleRob_x_pos&quot;, &quot;Data0&quot; to &quot;bubbleRob_y_pos&quot;, &quot;Data1&quot; to &quot;bubbleRob_z_pos&quot;, &quot;Data2&quot; to &quot;bubbleRob_obstacle_dist&quot;.
</p>

<p>Select &quot;bubbleRob_x_pos&quot; in the <strong>Data Stream recording list</strong> and in the <strong>Time graph properties</strong> section, uncheck <strong>Visible</strong>. Do the same for &quot;bubbleRob_y_pos&quot; and &quot;bubbleRob_z_pos&quot;. By doing so, only the &quot;bubbleRob_obstacle_dist&quot; data stream will be visible in a time graph. Following is what you should have:</p>


<p align=center><img src="images/bubbleRobTut12.jpg"></p>
<br>



<p>Next we will set-up a 3D curve that displays BubbleRob's trajectory: click <strong>Edit 3D curves</strong> to open the<a href="graphCurvePropertiesDialog.htm"> XY graph and 3D curve dialog</a>. Click <strong>Add new curve</strong>. In the dialog that pops open, select &quot;bubbleRob_x_pos&quot; for the <strong>X-value</strong> item, &quot;bubbleRob_y_pos&quot; for the <strong>Y-value</strong> item and &quot;bubbleRob_z_pos&quot; for the <strong>Z-value</strong> item. Rename the newly added curve from &quot;Curve&quot; to &quot;bubbleRobPath&quot;.  Finally, check the <strong>Relative to world</strong> item and set <strong>Curve width</strong> to 4:<br>
</p>

<p align=center><img src="images/bubbleRobTut12b.jpg"></p>
<br>

<p>Close all dialogs related to graphs. Now set one motor target velocity to 50, run the simulation, and you will see BubbleRob's trajectory displayed in the scene. Stop the simulation and reset the motor target velocity to zero.<br>
</p>

<p>Next, let's add a visualization window for the minimum distance data stream. In the scene, click [Popup menu --&gt; Add --&gt; Floating view]. Select &quot;bubbleRobGraph&quot; then in the <a href="pagesAndViews.htm">floating view</a> right-click [Popup menu --&gt; View --&gt; Associate view with selected graph]. Running the simulation will not yet display anything in the graph window, since there are still no objects (i.e. obstacles) to measure against. Let's now add some obstacles!<br>
</p>


<p>Add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). For the cylinder also activate layer 9 (but keep layer 1 activated). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, in the shape dynamics dialog, keep <strong>Respondable</strong> checked but also check <strong>Static</strong>. In addition we want the cylinder to be detectable by proximity sensors, measurable, collidable and renderable too: check the appropriate items in the object common properties dialog.  Now while the cylinder is still selected, click the object translation toolbar button (alternatively, a click on the mouse wheel alternates between the camera pan,  the object translate and the object rotate mode):<br>
</p>
<p align=center><img src="images/objectShiftButton.jpg"></p>
<br>


<p>Now click and drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. Then copy the cylinder and paste it a few times into the scene and move them to positions around BubbleRob (it is most convenient to perform that while looking at the scene as displayed on page 6: from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the &quot;regular&quot; direction(s). When done, select the camera pan toolbar button:<br>
</p>


<p align=center><img src="images/cameraShiftButton.jpg"></p>
<br>

<p>Set a target velocity of 50 to the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. Stop the simulation and reset the target velocity to zero.<br>
</p>

<p>Let us now finish BubbleRob as a <a href="models.htm">model</a> definition. For the left and right joints, deactivate layer 2 and activate layer 10. Joints are now hidden in layer 10. Instead of making an object invisible, try simply moving it to a layer 8 levels above, so that at any time the whole scene content can easily be inspected by activating/deactivation scene layers. Select &quot;bubbleRob&quot;, and  then check the <strong>Object is model base</strong> item in the object common properties dialog. An object with that item enabled will have a stippled bounding box that encompasses all objects built on its hierarchy. Additionally, when such an object is copied, all its tree hierarchy is also automatically copied. This makes handling of BubbleRob very easy and similar to handling a single object (try to copy only the &quot;bubbleRob&quot; object, and to paste it into another scene: all attached objects are also pasted!).<br>
</p>

<p>Next, for each object in the &quot;bubbleRob&quot; tree, except for &quot;bubbleRob&quot;, check the <strong>Select base of model instead</strong> item in the object common properties dialog. Now try selecting any BubbleRob object in the scene: whatever you click on BubbleRob, only its base gets selected! BubbleRob now appears to us as a single object (individual objects however still can be selected through the scene hierarchy, or by holding the shift and ctrl keys down while clicking the object). Finally, for both joints, check the <strong>Don't show as inside model selection</strong> checkbox. This is what you should have by now:<br>
</p>

<p align=center><img src="images/bubbleRobTut13.jpg"></p>
<br>

<p>Next we will add a <a href="visionSensors.htm">vision sensor</a>, at the same position and orientation as BubbleRob's proximity sensor: click [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type]. Make the vision sensor child of &quot;sensingNose&quot;, and set the local position and orientation of the vision sensor to (0,0,0). Select the vision sensor and open <a href="visionSensorPropertiesDialog.htm">its properties</a> dialog. Set the <strong>Far clipping plane</strong> item to 1, and the <strong>Resolution x</strong> and <strong>Resolution y</strong> items to 256 and 256. Open the <a href="visionSensorFilterDialog.htm">vision sensor filter dialog</a> by clicking <strong>Show filter dialog</strong>. Select the filter component &quot;Edge detection on work image&quot; and click <strong>Add filter</strong>. Position the newly added filter in second position (one position up, using the <strong>up</strong> button).  Double-click the newly added filter component and adjust its <strong>Threshold</strong> item to 0.2, then click <strong>OK</strong>. Open the object common properties dialog and check the <strong>Select base of model instead</strong> and <strong>Don't show as inside model selection</strong> items. At this stage you can also check the <strong>Don't show as inside model selection</strong> item for the two joints so as to have the model bounding box only encompass visible objects. Move the vision sensor to layer 12. Add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --&gt; View --&gt; Associate view with selected vision sensor]. To be able to see the vision sensor's image, start the simulation. Stop it again.<br>
</p>

<p>Next, we want to be able to modulate BubbleRob's velocity with a customized user interface. For that we will use a <a href="customUserInterfaces.htm">custom user interface</a>: click [Menu bar --&gt; Tools --&gt; Custom user interfaces] to open the <a href="customUserInterfacePropertiesDialog.htm">custom user interface dialog</a>. Alternatively you can also access it by clicking the appropriate toolbar button:<br>
</p>

<p align=center><img src="images/customUserInterfaceButton.jpg"></p>
<br>

<p>Click<strong> Add new user interface</strong>. Enter 2 for the <strong>Client y-size</strong> item, keep the rest unchanged and then click <strong>OK</strong>. A new custom user interface was added to the scene (in the middle of the page).  In the custom user interface dialog rename it to &quot;bubbleCtrl&quot;:<br>
</p>

<p align=center><img src="images/bubbleRobTut14.jpg"></p>
<br>

<p>In the page view, shift-select all free cells of the custom user interface, and click <strong>Insert merged button</strong> in the custom user interface dialog (the custom user interface dialog is context sensitive). The selected cells were replaced by a single button. Notice the <strong>Button handle</strong> item when the new button is selected: 3. This number can be used at a later stage to programmatically access that button. Select &quot;Slider&quot; as <strong>type</strong>. The button changed to a slider. Deselect all cells, then select &quot;bubbleRob&quot; under <strong>UI is associated with</strong> select &quot;bubbleRob&quot;. This is important so that the custom user interface is also automatically copied if &quot;bubbleRob&quot; is copied, or also automatically saved if &quot;bubbleRob&quot; is saved as a model. Finally, check the <strong>UI is visible only during simulation</strong> item. Leave the custom user interface edit mode by closing its dialog. Switch back to page 1.<br>
</p>

<p>The last thing what we need for our scene is a small <a href="childScripts.htm">child script</a> that will control BubbleRob's behavior. Select &quot;bubbleRob&quot; and click [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. This just added a <a href="childScripts.htm#nonThreaded">non-threaded child script</a> to the scene, and associated it with &quot;bubbleRob&quot;. You can also add, remove or modify child scripts (or the <a href="mainScript.htm">main script</a>) through the <a href="scriptProperties.htm">script dialog</a> which can be opened with [Menu bar --&gt; Tools --&gt; Scripts] or through the appropriate toolbar button:<br>
</p>

<p align=center><img src="images/scriptPropDialog1.jpg"></p>
<br>

<p>Double-click the little script icon that appeared next to &quot;bubbleRob&quot;'s dummy icon in the scene hierarchy: this opens the child script that we just added. Copy and paste following code into the <a href="scriptEditor.htm">script editor</a>, then close it:<br>
</p>

<pre class=lightRedBox>
if (sim_call_type==sim_childscriptcall_initialization) then 
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=simGetObjectAssociatedWithScript(sim_handle_self) -- this is bubbleRob's handle
    -- following is the handle of bubbleRob's associated UI (user interface):
    ctrl=simGetUIHandle("bubbleCtrl")
    -- Set the title of the user interface: 
    simSetUIButtonLabel(ctrl,0,simGetObjectName(bubbleRobBase).." speed") 
    leftMotor=simGetObjectHandle("leftMotor") -- Handle of the left motor
    rightMotor=simGetObjectHandle("rightMotor") -- Handle of the right motor
    noseSensor=simGetObjectHandle("sensingNose") -- Handle of the proximity sensor
    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
end

if (sim_call_type==sim_childscriptcall_cleanup) then 
 
end 

if (sim_call_type==sim_childscriptcall_sensing) then 

end 

if (sim_call_type==sim_childscriptcall_actuation) then 
    -- Retrieve the desired speed from the user interface: 
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*simGetUISlider(ctrl,3)/1000 

    result=simReadProximitySensor(noseSensor) -- Read the proximity sensor
    -- If we detected something, we set the backward mode:
    if (result>0) then backUntilTime=simGetSimulationTime()+4 end 

    if (backUntilTime&#60simGetSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        simSetJointTargetVelocity(leftMotor,speed)
        simSetJointTargetVelocity(rightMotor,speed)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        simSetJointTargetVelocity(leftMotor,-speed/2)
        simSetJointTargetVelocity(rightMotor,-speed/8)
    end
end</pre>

<p>Run the simulation. BubbleRob now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change BubbleRob's velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation. You can turn that functionality on and off in the distance dialog, by checking / unchecking the <strong>Enable all distance calculations</strong> item.</p>
<p>Using a script to control a robot or model is only one way of doing. V-REP offers many different ways (also combined), have a look at the <a href="externalControllerTutorial.htm">external controller tutorial</a>, or the <a href="pluginTutorial.htm">plugin tutorial</a>.<br>
</p>

<br>
<br>

 </tr>
</table> 
</div>  
  
  
</body>

</html>
